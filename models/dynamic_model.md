# Omnidirectional Robot Dynamics Model

This model describes a 4-wheel omnidirectional robot (X-configuration) using Euler integration to update its state over discrete time steps ($\Delta t = 0.016$ s). It accounts for physical limits like mass, rotational inertia, motor force limits, and wheel traction.

## 1. State and Command Vectors

The robot's state is defined in the **Global Frame** ($\mathcal{F}_G$):
$$ \mathbf{s}_k = [x, y, \theta, v_x, v_y, \omega]^T \in \mathbb{R}^6 $$

The control command is defined in the **Local Body Frame** ($\mathcal{F}_L$):
$$ \mathbf{u}_k = [v_x^{cmd}, v_y^{cmd}, \omega^{cmd}]^T \in \mathbb{R}^3 $$

---

## 2. Velocity Limits & Saturation

Before applying commands, the requested velocities are saturated by the robot's physical maximums ($v_{max}$ and $\omega_{max}$). To preserve the intended path curvature, the linear velocity is scaled proportionally rather than clipped independently:

$$ \text{scale} = \min\left(1.0, \frac{v_{max}}{\sqrt{(v_x^{cmd})^2 + (v_y^{cmd})^2}}\right) $$
$$ \mathbf{v}_{linear}^{req} = \text{scale} \cdot [v_x^{cmd}, v_y^{cmd}]^T $$
$$ \omega^{req} = \text{clip}(\omega^{cmd}, -\omega_{max}, \omega_{max}) $$

---

## 3. Frame Transformation (Global to Local)

To calculate required internal forces, the current global velocity is rotated into the local body frame using the current heading ($\theta$):

$$ \begin{bmatrix} v_x^{loc} \\ v_y^{loc} \end{bmatrix} = \begin{bmatrix} \cos\theta & \sin\theta \\ -\sin\theta & \cos\theta \end{bmatrix} \begin{bmatrix} v_x \\ v_y \end{bmatrix} $$

---

## 4. Inverse Dynamics (Required Forces)

The model determines the ideal forces required to reach the commanded velocities within a single time step ($\Delta t$). 

First, the required accelerations are computed:
$$ \mathbf{a}_{req} = \begin{bmatrix} a_x^{req} \\ a_y^{req} \\ \alpha^{req} \end{bmatrix} = \frac{1}{\Delta t} \begin{bmatrix} v_x^{req} - v_x^{loc} \\ v_y^{req} - v_y^{loc} \\ \omega^{req} - \omega \end{bmatrix} $$

Using Newton's Second Law ($F=ma$ and $\tau=I\alpha$), the required body forces ($\mathbf{F}_{body}^{req}$) are:
$$ \mathbf{F}_{body}^{req} = \begin{bmatrix} F_x^{req} \\ F_y^{req} \\ \tau^{req} \end{bmatrix} = \begin{bmatrix} m \cdot a_x^{req} \\ m \cdot a_y^{req} \\ I \cdot \alpha^{req} \end{bmatrix} $$
*(where $m$ is the body mass and $I$ is the rotational inertia)*

---

## 5. Wheel Kinematics and Force Distribution


The robot uses four wheels arranged at angles $\alpha_i \in \{\frac{\pi}{4}, \frac{3\pi}{4}, \frac{5\pi}{4}, \frac{7\pi}{4}\}$ at a distance $R$ from the center. The kinematic coupling matrix $H \in \mathbb{R}^{4 \times 3}$ maps individual wheel states to the robot's body state:

$$ H = \begin{bmatrix} -\sin\alpha_1 & \cos\alpha_1 & R \\ -\sin\alpha_2 & \cos\alpha_2 & R \\ -\sin\alpha_3 & \cos\alpha_3 & R \\ -\sin\alpha_4 & \cos\alpha_4 & R \end{bmatrix} $$

To find the optimal force distribution across the four wheels to achieve the required body force, the model uses the Moore-Penrose pseudo-inverse of $H^T$:
$$ \mathbf{F}_{w}^{req} = \mathbf{F}_{body}^{req} \left( (H^T)^+ \right)^T $$
*(where $\mathbf{F}_{w}^{req} \in \mathbb{R}^{1 \times 4}$ is the vector of forces required at each wheel).*

---

## 6. Physical Constraints (Motor Limits & Friction)

A wheel's generated force is limited by the motor's maximum output ($F_{motor}$) and the traction limit of the tire against the ground ($F_{friction}$). The maximum achievable wheel force is the lesser of the two:

$$ F_{limit} = \min(F_{motor}, F_{friction}) $$

The actual forces produced by the wheels are clipped to this physical limit:
$$ \mathbf{F}_{w}^{act} = \text{clip}(\mathbf{F}_{w}^{req}, -F_{limit}, F_{limit}) $$

---

## 7. Forward Dynamics (Actual Accelerations)

The actual forces generated by the wheels are mapped back to the resulting body forces:
$$ \mathbf{F}_{body}^{act} = \mathbf{F}_{w}^{act} H $$

These forces dictate the true achievable acceleration of the chassis:
$$ \mathbf{a}_{act} = \begin{bmatrix} F_{x}^{act} / m \\ F_{y}^{act} / m \\ \tau^{act} / I \end{bmatrix} $$

---

## 8. Numerical Integration (Euler Method)

Finally, the state is updated by integrating the achievable accelerations.

**1. Update Local Velocities:**
$$ \mathbf{v}_{new}^{loc} = \mathbf{v}^{loc} + \mathbf{a}_{act} \Delta t $$

**2. Transform back to Global Frame:**
$$ \begin{bmatrix} v_{x, new} \\ v_{y, new} \end{bmatrix} = \begin{bmatrix} \cos\theta & -\sin\theta \\ \sin\theta & \cos\theta \end{bmatrix} \begin{bmatrix} v_{x, new}^{loc} \\ v_{y, new}^{loc} \end{bmatrix} $$

**3. Compute State Deltas ($\Delta \mathbf{s}$):**
$$ \Delta x = v_{x, new} \Delta t $$
$$ \Delta y = v_{y, new} \Delta t $$
$$ \Delta \theta = \omega_{new} \Delta t $$
$$ \Delta v_x = v_{x, new} - v_x $$
$$ \Delta v_y = v_{y, new} - v_y $$
$$ \Delta \omega = \omega_{new} - \omega $$

The model applies these deltas, wrapping $\theta$ to $[-\pi, \pi]$, to output the next global state $\mathbf{s}_{k+1}$.